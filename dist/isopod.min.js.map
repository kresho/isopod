{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///isopod.min.js","webpack:///webpack/bootstrap 92579274967d6b51bfbb","webpack:///./src/isopod.js","webpack:///./src/utils.js","webpack:///./src/deserialize.js","webpack:///./src/serialize.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","isopod","serialize","deserialize","global","each","obj","fn","Object","keys","forEach","k","flags","r","ignoreCase","multiline","sticky","baseTypeOf","thing","prototype","toString","slice","isopodTypeOf","type","specialTypes","has","hostGlobals","allowedTypes","getSymbolString","sym","match","parensPattern","hasNonNativeConstructor","hasOwnProperty","nativeConstructors","constructor","isSimple","isRef","_typeof","isPlainOrTypedArray","typedArrayTypes","hostObjFromPath","path","reduce","key","e","Symbol","iterator","typedArrayConstructors","Set","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","add","name","bufferableConstructors","DataView","bufferableTypes","Map","set","undefined","NaN","Infinity","Boolean","Number","Function","Array","RegExp","Error","ArrayBuffer","Date","nativePrototypes","specialType","globallyAccessible","queue","value","length","item","shift","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","getOwnPropertyNames","concat","next","done","propertyName","child","push","err","typedFromDehydrated","dehydrated","source","eval","message","stack","defineProperty","enumerable","buffer","utils","hydrateOne","hydrated","refs","possibleRef","v","isArray","elem","mapEntry","serialized","mapping","todoBufferables","map","index","emptyHydrated","get","byteOffset","bufferable","bufferableSource","currentProto","getPrototypeOf","originalProto","setPrototypeOf","assoc","original","idCache","sourceValueFrom","dehydrate","_ret","_ret2","valueOf","cloneKeys","clone","proto","_constructor","isNaN"],"mappings":"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","file":"isopod.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"isopod\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"isopod\"] = factory();\n\telse\n\t\troot[\"isopod\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"isopod\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"isopod\"] = factory();\n\telse\n\t\troot[\"isopod\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isopod = {\n\t  serialize: __webpack_require__(3),\n\t  deserialize: __webpack_require__(2)\n\t};\n\t\n\tmodule.exports = isopod;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction each(obj, fn) {\n\t  Object.keys(obj).forEach(function (k) {\n\t    fn(k, obj[k]);\n\t  });\n\t};\n\t\n\tfunction flags(r) {\n\t  if (r.flags) return r.flags;\n\t  return (r.ignoreCase ? 'i' : '') + (r.multiline ? 'm' : '') + (r.global ? 'g' : '') + (r.sticky ? 'y' : '');\n\t};\n\t\n\tvar typedArrayConstructors = new Set([Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]);\n\t\n\tvar typedArrayTypes = new Set();\n\ttypedArrayConstructors.forEach(function (constructor) {\n\t  typedArrayTypes.add(constructor.name);\n\t});\n\t\n\tvar bufferableConstructors = new Set([DataView]);\n\ttypedArrayConstructors.forEach(function (constructor) {\n\t  bufferableConstructors.add(constructor);\n\t});\n\t\n\tvar bufferableTypes = new Map();\n\tbufferableConstructors.forEach(function (constructor) {\n\t  bufferableTypes.set(constructor.name, constructor);\n\t});\n\t\n\tvar specialTypes = new Set([undefined, null, NaN, Infinity, -Infinity]);\n\t\n\tvar nativeConstructors = new Set([Boolean, Number, Object, Function, Set, Symbol, Array, Map, RegExp, Error, ArrayBuffer, Date]);\n\tbufferableConstructors.forEach(function (constructor) {\n\t  nativeConstructors.add(constructor);\n\t});\n\t\n\tvar nativePrototypes = new Set();\n\tnativeConstructors.forEach(function (constructor) {\n\t  nativePrototypes.add(constructor.prototype);\n\t});\n\t\n\tvar allowedTypes = new Set();\n\tnativeConstructors.forEach(function (constructor) {\n\t  allowedTypes.add(constructor.name);\n\t});\n\tspecialTypes.forEach(function (specialType) {\n\t  allowedTypes.add('' + specialType);\n\t});\n\tallowedTypes.add('HostGlobal');\n\t\n\tfunction baseTypeOf(thing) {\n\t  return Object.prototype.toString.call(thing).slice(8, -1);\n\t}\n\t\n\tfunction isopodTypeOf(thing) {\n\t  var type = specialTypes.has(thing) ? '' + thing : hostGlobals.has(thing) ? 'HostGlobal' : baseTypeOf(thing);\n\t  return allowedTypes.has(type) ? type : 'Unsupported:' + type; // TODO: consider throwing error for unsupported types\n\t}\n\t\n\tvar parensPattern = /\\(.+\\)/;\n\tfunction getSymbolString(sym) {\n\t  return sym.toString().match(parensPattern)[0].slice(1, -1);\n\t}\n\t\n\tfunction hasNonNativeConstructor(obj) {\n\t  return Object.prototype.hasOwnProperty.call(obj, 'constructor') && !nativeConstructors.has(obj.constructor);\n\t}\n\t\n\tfunction isSimple(thing) {\n\t  return !specialTypes.has(thing) && !isRef(thing);\n\t}\n\t\n\tfunction isRef(thing) {\n\t  return (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'symbol' || typeof thing === 'function' || (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object' && thing !== null;\n\t}\n\t\n\tfunction isPlainOrTypedArray(thing) {\n\t  var type = baseTypeOf(thing);\n\t  return type === 'Array' || typedArrayTypes.has(type);\n\t}\n\t\n\tvar hostGlobals = function () {\n\t  var globallyAccessible = new Map();\n\t  var queue = [{\n\t    value: global,\n\t    path: []\n\t  }];\n\t  while (queue.length) {\n\t    var item = queue.shift();\n\t    var obj = item.value;\n\t    var path = item.path;\n\t    if (globallyAccessible.has(obj)) continue;\n\t    globallyAccessible.set(obj, path);\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t      for (var _iterator = Object.getOwnPropertyNames(obj).concat(['__proto__'])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var propertyName = _step.value;\n\t\n\t        var child = void 0;\n\t        try {\n\t          child = obj[propertyName];\n\t        } catch (e) {\n\t          continue;\n\t        }\n\t        if (!isRef(child)) continue;\n\t        queue.push({\n\t          value: child,\n\t          path: path.concat([propertyName])\n\t        });\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return globallyAccessible;\n\t}();\n\t\n\tfunction hostObjFromPath(path) {\n\t  try {\n\t    return path.reduce(function (obj, key) {\n\t      return obj[key];\n\t    }, global);\n\t  } catch (e) {}\n\t}\n\t\n\tmodule.exports = {\n\t  each: each,\n\t  flags: flags,\n\t  bufferableTypes: bufferableTypes,\n\t  specialTypes: specialTypes,\n\t  nativePrototypes: nativePrototypes,\n\t  isopodTypeOf: isopodTypeOf,\n\t  getSymbolString: getSymbolString,\n\t  hasNonNativeConstructor: hasNonNativeConstructor,\n\t  isSimple: isSimple,\n\t  isPlainOrTypedArray: isPlainOrTypedArray,\n\t  hostGlobals: hostGlobals,\n\t  hostObjFromPath: hostObjFromPath\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(1);\n\t\n\t// convert a dehydrated object back into something of the correct type\n\tfunction typedFromDehydrated(dehydrated) {\n\t  switch (dehydrated.type) {\n\t    case 'Symbol':\n\t      return Symbol(dehydrated.source);\n\t    case 'Function':\n\t      return eval('(' + dehydrated.source + ')'); // TODO: alternative to eval\n\t    case 'Set':\n\t      return new Set();\n\t    case 'Map':\n\t      return new Map();\n\t    case 'Array':\n\t      return [];\n\t    case 'RegExp':\n\t      return new RegExp(dehydrated.source[0], dehydrated.source[1]);\n\t    case 'Error':\n\t      {\n\t        var err = Error(dehydrated.source.message);\n\t        if (dehydrated.source.stack) {\n\t          Object.defineProperty(err, 'stack', {\n\t            value: dehydrated.source.stack,\n\t            enumerable: false\n\t          });\n\t        }\n\t        return err;\n\t      }\n\t    case 'Object':\n\t      return {};\n\t    case 'null':\n\t      return null;\n\t    case 'undefined':\n\t      return undefined;\n\t    case 'NaN':\n\t      return NaN;\n\t    case 'Infinity':\n\t      return Infinity;\n\t    case '-Infinity':\n\t      return -Infinity;\n\t    case 'ArrayBuffer':\n\t      return new Uint8Array(dehydrated.source).buffer;\n\t    case 'Date':\n\t      return new Date(dehydrated.source);\n\t    case 'HostGlobal':\n\t      return utils.hostObjFromPath(dehydrated.source);\n\t  }\n\t}\n\t\n\t// use the dehydrated format to populate an empty object of the correct type\n\tfunction hydrateOne(hydrated, dehydrated, refs) {\n\t  // special values and host globals need no further hydration\n\t  if (utils.specialTypes.has(hydrated) || utils.hostGlobals.has(hydrated)) return;\n\t  // account for any objects that are duplicate references\n\t  function possibleRef(v) {\n\t    return Array.isArray(v) ? refs[v[0]] : v;\n\t  }\n\t  switch (dehydrated.type) {\n\t    case 'Set':\n\t      {\n\t        // a set incorporates its source array as elements\n\t        dehydrated.source.forEach(function (elem) {\n\t          hydrated.add(possibleRef(elem));\n\t        });\n\t        break;\n\t      }\n\t    case 'Map':\n\t      {\n\t        // a map incorporates its source array as key-value entries\n\t        dehydrated.source.forEach(function (mapEntry) {\n\t          var k = mapEntry[0]; // TODO: could replace with destructuring\n\t          var v = mapEntry[1]; // TODO: could replace with destructuring\n\t          hydrated.set(possibleRef(k), possibleRef(v));\n\t        });\n\t        break;\n\t      }\n\t    case 'Array':\n\t      {\n\t        // an array incorporates its source array as elements\n\t        dehydrated.source.forEach(function (elem) {\n\t          hydrated.push(possibleRef(elem));\n\t        });\n\t        break;\n\t      }\n\t  }\n\t  // incorporate any additional keys from the dehydrated object\n\t  utils.each(dehydrated.keys, function (k, v) {\n\t    if (k === 'constructor') {\n\t      Object.defineProperty(hydrated, 'constructor', {\n\t        value: possibleRef(v),\n\t        enumerable: false\n\t      });\n\t    } else {\n\t      hydrated[k] = possibleRef(v);\n\t    }\n\t  });\n\t}\n\t\n\t// convert a serialized thing into a fully imbued clone of the original, i.e. the one that got serialized in the first place\n\tfunction deserialize(serialized) {\n\t  // if the base serialized root is not an array it is simply a primitive value\n\t  if (!Array.isArray(serialized)) return serialized;\n\t  // the mapping corresponds the being-hydrated and dehydrated versions of the data\n\t  var mapping = new Map();\n\t  // stores bufferables to get to after the first pass\n\t  var todoBufferables = new Map();\n\t  // hold references to the being-hydrated objects\n\t  var refs = serialized.map(function (dehydrated, index) {\n\t    if (utils.bufferableTypes.has(dehydrated.type)) {\n\t      // will need the dehydrated version and index in refs array for later use\n\t      todoBufferables.set(dehydrated, index);\n\t    } else {\n\t      var emptyHydrated = typedFromDehydrated(dehydrated);\n\t      mapping.set(dehydrated, emptyHydrated);\n\t      return emptyHydrated;\n\t    }\n\t  });\n\t  // bufferables cannot be constructed as empty and filled in later, they need their underlying buffer at construction time, which we only have access to after the first pass\n\t  todoBufferables.forEach(function (index, dehydrated) {\n\t    var constructor = utils.bufferableTypes.get(dehydrated.type);\n\t    var buffer = refs[dehydrated.source.buffer[0]];\n\t    var byteOffset = dehydrated.source.byteOffset;\n\t    var length = dehydrated.source.length;\n\t    var bufferable = new constructor(buffer, byteOffset, length);\n\t    // attach properly typed reference at that index\n\t    refs[index] = bufferable;\n\t    // include properly typed reference to be further enriched in the final hydration step\n\t    mapping.set(dehydrated, bufferable);\n\t  });\n\t  // final pass, imbue each empty (but properly typed) object with all its glorious details\n\t  mapping.forEach(function (emptyHydrated, dehydrated) {\n\t    hydrateOne(emptyHydrated, dehydrated, refs);\n\t  });\n\t  // the first ref is now a clone of the base object that was originally serialized\n\t  return refs[0];\n\t};\n\t\n\tmodule.exports = deserialize;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar utils = __webpack_require__(1);\n\t\n\tfunction bufferableSource(bufferable) {\n\t  // in case a bufferable has a non-standard prototype\n\t  var currentProto = Object.getPrototypeOf(bufferable);\n\t  var originalProto = utils.bufferableTypes.get(utils.isopodTypeOf(bufferable)).prototype;\n\t  // temporarily change prototype back to original\n\t  Object.setPrototypeOf(bufferable, originalProto);\n\t  // a bufferable's source contains its buffer, the byteOffset, and the length\n\t  var source = {\n\t    buffer: bufferable.buffer,\n\t    byteOffset: bufferable.byteOffset,\n\t    length: bufferable.length\n\t  };\n\t  // change back to assigned prototype\n\t  Object.setPrototypeOf(bufferable, currentProto);\n\t  return source;\n\t}\n\t\n\t// given some object or primitive, convert it into a format that will retain all its details when stringified\n\tfunction serialize(root) {\n\t\n\t  // deal with trivial case\n\t  if (utils.isSimple(root)) return root;\n\t\n\t  // the serialized result will be an array of \"dehydrated\" objects\n\t  var serialized = [];\n\t  // the idCache keeps track of any objects (or symbols) that have been seen already\n\t  var idCache = new Map();\n\t\n\t  // incorporate an object (or symbol) into the cache and return the seed of a dehydrated stand-in\n\t  function assoc(original) {\n\t    var dehydrated = {};\n\t    // the id represents the location of the dehydrated object in the root serialized array\n\t    var id = serialized.push(dehydrated) - 1;\n\t    idCache.set(original, id);\n\t    return dehydrated;\n\t  }\n\t\n\t  // catch-all to obtain various meaningful \"source\" values from native Object types\n\t  function sourceValueFrom(original, type) {\n\t    // objects and special values don't have a \"source\"\n\t    if (type === 'Object' || utils.specialTypes.has(original)) return;\n\t    if (utils.bufferableTypes.has(type)) {\n\t      // make sure to attach the buffer by reference\n\t      var source = bufferableSource(original);\n\t      source.buffer = dehydrate(source.buffer);\n\t      return source;\n\t    }\n\t    switch (type) {\n\t      // a symbol's source is the string used to construct it\n\t      case 'Symbol':\n\t        return utils.getSymbolString(original);\n\t      // a function's source is its source string\n\t      case 'Function':\n\t        return Function.prototype.toString.call(original);\n\t      case 'RegExp':\n\t        return [original.source, utils.flags(original)];\n\t      case 'Error':\n\t        {\n\t          return {\n\t            message: Object.prototype.hasOwnProperty.call(original, 'message') ? original.message : undefined,\n\t            stack: original.stack\n\t          };\n\t        }\n\t      // an array's source is an array copy of its elements\n\t      case 'Array':\n\t        return Array.prototype.map.call(original, dehydrate);\n\t      case 'Set':\n\t        {\n\t          var _ret = function () {\n\t            // a set's source is an array of the set elements\n\t            var source = [];\n\t            Set.prototype.forEach.call(original, function (elem) {\n\t              source.push(dehydrate(elem));\n\t            });\n\t            return {\n\t              v: source\n\t            };\n\t          }();\n\t\n\t          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        }\n\t      case 'Map':\n\t        {\n\t          var _ret2 = function () {\n\t            // a map's source is an array of key-value pair arrays\n\t            var source = [];\n\t            Map.prototype.forEach.call(original, function (v, k) {\n\t              source.push([k, v].map(dehydrate));\n\t            });\n\t            return {\n\t              v: source\n\t            };\n\t          }();\n\t\n\t          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        }\n\t      // an array buffer's source is its Uint8Array representation\n\t      case 'ArrayBuffer':\n\t        return Array.prototype.slice.call(new Uint8Array(original));\n\t      case 'Date':\n\t        return Date.prototype.valueOf.call(original);\n\t      case 'HostGlobal':\n\t        return utils.hostGlobals.get(original);\n\t    }\n\t  }\n\t\n\t  // return any keys in the original not accounted for in the source\n\t  function cloneKeys(original, source) {\n\t    // special values do not have keys, host globals don't need 'em\n\t    if (utils.specialTypes.has(original) || utils.hostGlobals.has(original)) return;\n\t    var clone = {};\n\t    var proto = Object.getPrototypeOf(original);\n\t    // include original's __proto__ when cloning it, if it's non-native\n\t    if (!utils.nativePrototypes.has(proto)) {\n\t      Object.defineProperty(clone, '__proto__', {\n\t        value: dehydrate(proto),\n\t        enumerable: true // ensure that it will show up as a result of stringification\n\t      });\n\t    }\n\t    // include the original's constructor if it has one\n\t    if (utils.hasNonNativeConstructor(original)) {\n\t      var _constructor = original.constructor;\n\t      if (_constructor instanceof Object && _constructor.prototype === original) {\n\t        clone.constructor = dehydrate(_constructor);\n\t      }\n\t    }\n\t    // include all keys in original not yet accounted for by the source\n\t    utils.each(original, function (k, v) {\n\t      // make sure not to double include numerical array keys already in the source\n\t      if (source && utils.isPlainOrTypedArray(original) && !Number.isNaN(Number(k))) return;\n\t      clone[k] = dehydrate(v);\n\t    });\n\t    return clone;\n\t  }\n\t\n\t  // convert something into a rehydratable format\n\t  function dehydrate(thing) {\n\t    // simple values (non-special booleans, numbers, and strings) remain themselves\n\t    if (utils.isSimple(thing)) return thing;\n\t    if (!idCache.has(thing)) {\n\t      // incorporate the object into the cache\n\t      var dehydrated = assoc(thing);\n\t      // set its type (helps streamline deserialization)\n\t      dehydrated.type = utils.isopodTypeOf(thing);\n\t      // set its \"source\" value (helps streamline deserialization)\n\t      dehydrated.source = sourceValueFrom(thing, dehydrated.type);\n\t      // set any additional keys not included in the source\n\t      dehydrated.keys = cloneKeys(thing, dehydrated.source);\n\t    }\n\t    // objects are replaced with the id representing their location in the root serialized array (helps streamline deserialization)\n\t    return [idCache.get(thing)];\n\t  }\n\t\n\t  // kick off the recursive process of dehydrating everything in the original\n\t  dehydrate(root);\n\t\n\t  return serialized;\n\t};\n\t\n\tmodule.exports = serialize;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** isopod.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 92579274967d6b51bfbb\n **/","'use strict';\n\nconst isopod = {\n  serialize: require('./serialize'),\n  deserialize: require('./deserialize')\n};\n\nmodule.exports = isopod;\n\n\n/** WEBPACK FOOTER **\n ** ./src/isopod.js\n **/","'use strict';\n\nfunction each (obj, fn) {\n  Object.keys(obj).forEach(function (k) {\n    fn(k, obj[k]);\n  });\n};\n\nfunction flags (r) {\n  if (r.flags) return r.flags;\n  return (r.ignoreCase ? 'i' : '') + (r.multiline ? 'm' : '') + (r.global ? 'g' : '') + (r.sticky ? 'y' : '');\n};\n\nconst typedArrayConstructors = new Set([\n  Int8Array,\n  Uint8Array,\n  Uint8ClampedArray,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array\n]);\n\nconst typedArrayTypes = new Set();\ntypedArrayConstructors.forEach(function (constructor) {\n  typedArrayTypes.add(constructor.name);\n});\n\nconst bufferableConstructors = new Set([\n  DataView\n]);\ntypedArrayConstructors.forEach(function (constructor) {\n  bufferableConstructors.add(constructor);\n});\n\nconst bufferableTypes = new Map();\nbufferableConstructors.forEach(function (constructor) {\n  bufferableTypes.set(constructor.name, constructor);\n});\n\nconst specialTypes = new Set([\n  undefined,\n  null,\n  NaN,\n  Infinity,\n  -Infinity\n]);\n\nconst nativeConstructors = new Set([\n  Boolean,\n  Number,\n  Object,\n  Function,\n  Set,\n  Symbol,\n  Array,\n  Map,\n  RegExp,\n  Error,\n  ArrayBuffer,\n  Date\n]);\nbufferableConstructors.forEach(function (constructor) {\n  nativeConstructors.add(constructor);\n});\n\nconst nativePrototypes = new Set();\nnativeConstructors.forEach(function (constructor) {\n  nativePrototypes.add(constructor.prototype);\n});\n\nconst allowedTypes = new Set();\nnativeConstructors.forEach(function (constructor) {\n  allowedTypes.add(constructor.name);\n});\nspecialTypes.forEach(function (specialType) {\n  allowedTypes.add(`${specialType}`);\n});\nallowedTypes.add('HostGlobal');\n\nfunction baseTypeOf (thing) {\n  return Object.prototype.toString.call(thing).slice(8,-1);\n}\n\nfunction isopodTypeOf (thing) {\n  const type = specialTypes.has(thing) ? `${thing}` : hostGlobals.has(thing) ? 'HostGlobal' : baseTypeOf(thing);\n  return allowedTypes.has(type) ? type : `Unsupported:${type}`; // TODO: consider throwing error for unsupported types\n}\n\nconst parensPattern = /\\(.+\\)/;\nfunction getSymbolString (sym) {\n  return sym.toString().match(parensPattern)[0].slice(1,-1);\n}\n\nfunction hasNonNativeConstructor (obj) {\n  return Object.prototype.hasOwnProperty.call(obj, 'constructor') && !nativeConstructors.has(obj.constructor);\n}\n\nfunction isSimple (thing) {\n  return !specialTypes.has(thing) && !isRef(thing); \n}\n\nfunction isRef (thing) {\n  return typeof thing === 'symbol' || typeof thing === 'function' || typeof thing === 'object' && thing !== null;\n}\n\nfunction isPlainOrTypedArray (thing) {\n  const type = baseTypeOf(thing);\n  return type === 'Array' || typedArrayTypes.has(type);\n}\n\nconst hostGlobals = (function () {\n  const globallyAccessible = new Map();\n  const queue = [{\n    value: global,\n    path: []\n  }];\n  while (queue.length) {\n    const item = queue.shift();\n    const obj = item.value;\n    const path = item.path;\n    if (globallyAccessible.has(obj)) continue;\n    globallyAccessible.set(obj, path);\n    for (let propertyName of Object.getOwnPropertyNames(obj).concat(['__proto__'])) {\n      let child;\n      try {child = obj[propertyName];}\n      catch (e) {continue;}\n      if (!isRef(child)) continue;\n      queue.push({\n        value: child,\n        path: path.concat([propertyName])\n      });\n    }\n  }\n  return globallyAccessible;\n})();\n\nfunction hostObjFromPath (path) {\n  try {\n    return path.reduce(function (obj, key) {\n      return obj[key];\n    }, global);\n  } catch (e) {}\n}\n\nmodule.exports = {\n  each,\n  flags,\n  bufferableTypes,\n  specialTypes,\n  nativePrototypes,\n  isopodTypeOf,\n  getSymbolString,\n  hasNonNativeConstructor,\n  isSimple,\n  isPlainOrTypedArray,\n  hostGlobals,\n  hostObjFromPath\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","'use strict';\n\nconst utils = require('./utils');\n\n// convert a dehydrated object back into something of the correct type\nfunction typedFromDehydrated (dehydrated) {\n  switch (dehydrated.type) {\n    case 'Symbol': return Symbol(dehydrated.source);\n    case 'Function': return eval(`(${dehydrated.source})`); // TODO: alternative to eval\n    case 'Set': return new Set();\n    case 'Map': return new Map();\n    case 'Array': return [];\n    case 'RegExp': return new RegExp(dehydrated.source[0], dehydrated.source[1]);\n    case 'Error': {\n      const err = Error(dehydrated.source.message);\n      if (dehydrated.source.stack) {\n        Object.defineProperty(err, 'stack', {\n          value: dehydrated.source.stack,\n          enumerable: false\n        });\n      }\n      return err;\n    }\n    case 'Object': return {};\n    case 'null': return null;\n    case 'undefined': return undefined;\n    case 'NaN': return NaN;\n    case 'Infinity': return Infinity;\n    case '-Infinity': return -Infinity;\n    case 'ArrayBuffer': return new Uint8Array(dehydrated.source).buffer;\n    case 'Date': return new Date(dehydrated.source);\n    case 'HostGlobal': return utils.hostObjFromPath(dehydrated.source);\n  }\n}\n\n// use the dehydrated format to populate an empty object of the correct type\nfunction hydrateOne (hydrated, dehydrated, refs) {\n  // special values and host globals need no further hydration\n  if (utils.specialTypes.has(hydrated) || utils.hostGlobals.has(hydrated)) return;\n  // account for any objects that are duplicate references\n  function possibleRef (v) {\n    return Array.isArray(v) ? refs[v[0]] : v;\n  }\n  switch (dehydrated.type) {\n    case 'Set': {\n      // a set incorporates its source array as elements\n      dehydrated.source.forEach(function (elem) {\n        hydrated.add(possibleRef(elem));\n      });\n      break;\n    }\n    case 'Map': {\n      // a map incorporates its source array as key-value entries\n      dehydrated.source.forEach(function (mapEntry) {\n        const k = mapEntry[0]; // TODO: could replace with destructuring\n        const v = mapEntry[1]; // TODO: could replace with destructuring\n        hydrated.set(possibleRef(k), possibleRef(v));\n      });\n      break;\n    }\n    case 'Array': {\n      // an array incorporates its source array as elements\n      dehydrated.source.forEach(function (elem) {\n        hydrated.push(possibleRef(elem));\n      });\n      break;\n    }\n  }\n  // incorporate any additional keys from the dehydrated object\n  utils.each(dehydrated.keys, function (k, v) {\n    if (k === 'constructor') {\n      Object.defineProperty(hydrated, 'constructor', {\n        value: possibleRef(v),\n        enumerable: false\n      });\n    } else {\n      hydrated[k] = possibleRef(v);\n    }\n  });\n}\n\n// convert a serialized thing into a fully imbued clone of the original, i.e. the one that got serialized in the first place\nfunction deserialize (serialized) {\n  // if the base serialized root is not an array it is simply a primitive value\n  if (!Array.isArray(serialized)) return serialized;\n  // the mapping corresponds the being-hydrated and dehydrated versions of the data\n  const mapping = new Map();\n  // stores bufferables to get to after the first pass\n  const todoBufferables = new Map();\n  // hold references to the being-hydrated objects\n  const refs = serialized.map(function (dehydrated, index) {\n    if (utils.bufferableTypes.has(dehydrated.type)) {\n      // will need the dehydrated version and index in refs array for later use\n      todoBufferables.set(dehydrated, index);\n    } else {\n      const emptyHydrated = typedFromDehydrated(dehydrated);\n      mapping.set(dehydrated, emptyHydrated);\n      return emptyHydrated;\n    }\n  });\n  // bufferables cannot be constructed as empty and filled in later, they need their underlying buffer at construction time, which we only have access to after the first pass\n  todoBufferables.forEach(function (index, dehydrated) {\n    const constructor = utils.bufferableTypes.get(dehydrated.type);\n    const buffer = refs[dehydrated.source.buffer[0]];\n    const byteOffset = dehydrated.source.byteOffset;\n    const length = dehydrated.source.length;\n    const bufferable = new constructor(buffer, byteOffset, length);\n    // attach properly typed reference at that index\n    refs[index] = bufferable;\n    // include properly typed reference to be further enriched in the final hydration step\n    mapping.set(dehydrated, bufferable);\n  });\n  // final pass, imbue each empty (but properly typed) object with all its glorious details\n  mapping.forEach(function (emptyHydrated, dehydrated) {\n    hydrateOne(emptyHydrated, dehydrated, refs);\n  });\n  // the first ref is now a clone of the base object that was originally serialized\n  return refs[0];\n};\n\nmodule.exports = deserialize;\n\n\n/** WEBPACK FOOTER **\n ** ./src/deserialize.js\n **/","'use strict';\n\nconst utils = require('./utils');\n\nfunction bufferableSource (bufferable) {\n  // in case a bufferable has a non-standard prototype\n  const currentProto = Object.getPrototypeOf(bufferable);\n  const originalProto = utils.bufferableTypes.get(utils.isopodTypeOf(bufferable)).prototype;\n  // temporarily change prototype back to original\n  Object.setPrototypeOf(bufferable, originalProto);\n  // a bufferable's source contains its buffer, the byteOffset, and the length\n  const source = {\n    buffer: bufferable.buffer,\n    byteOffset: bufferable.byteOffset,\n    length: bufferable.length\n  };\n  // change back to assigned prototype\n  Object.setPrototypeOf(bufferable, currentProto);\n  return source;\n}\n\n// given some object or primitive, convert it into a format that will retain all its details when stringified\nfunction serialize (root) {\n\n  // deal with trivial case\n  if (utils.isSimple(root)) return root;\n\n  // the serialized result will be an array of \"dehydrated\" objects\n  const serialized = [];\n  // the idCache keeps track of any objects (or symbols) that have been seen already\n  const idCache = new Map();\n\n  // incorporate an object (or symbol) into the cache and return the seed of a dehydrated stand-in\n  function assoc (original) {\n    const dehydrated = {};\n    // the id represents the location of the dehydrated object in the root serialized array\n    const id = serialized.push(dehydrated)-1;\n    idCache.set(original, id);\n    return dehydrated;\n  }\n\n  // catch-all to obtain various meaningful \"source\" values from native Object types\n  function sourceValueFrom (original, type) {\n    // objects and special values don't have a \"source\"\n    if (type === 'Object' || utils.specialTypes.has(original)) return;\n    if (utils.bufferableTypes.has(type)) {\n      // make sure to attach the buffer by reference\n      const source = bufferableSource(original);\n      source.buffer = dehydrate(source.buffer);\n      return source;\n    }\n    switch (type) {\n      // a symbol's source is the string used to construct it\n      case 'Symbol': return utils.getSymbolString(original);\n      // a function's source is its source string\n      case 'Function': return Function.prototype.toString.call(original);\n      case 'RegExp': return [original.source, utils.flags(original)];\n      case 'Error': {\n        return {\n          message: Object.prototype.hasOwnProperty.call(original, 'message') ? original.message : undefined,\n          stack: original.stack\n        };\n      }\n      // an array's source is an array copy of its elements\n      case 'Array': return Array.prototype.map.call(original, dehydrate);\n      case 'Set': {\n        // a set's source is an array of the set elements\n        const source = [];\n        Set.prototype.forEach.call(original, function (elem) {\n          source.push(dehydrate(elem));\n        });\n        return source;\n      }\n      case 'Map': {\n        // a map's source is an array of key-value pair arrays\n        const source = [];\n        Map.prototype.forEach.call(original, function (v, k) {\n          source.push([k,v].map(dehydrate));\n        });\n        return source;\n      }\n      // an array buffer's source is its Uint8Array representation\n      case 'ArrayBuffer': return Array.prototype.slice.call(new Uint8Array(original));\n      case 'Date': return Date.prototype.valueOf.call(original);\n      case 'HostGlobal': return utils.hostGlobals.get(original);\n    }\n  }\n\n  // return any keys in the original not accounted for in the source\n  function cloneKeys (original, source) {\n    // special values do not have keys, host globals don't need 'em\n    if (utils.specialTypes.has(original) || utils.hostGlobals.has(original)) return;\n    const clone = {};\n    const proto = Object.getPrototypeOf(original);\n    // include original's __proto__ when cloning it, if it's non-native\n    if (!utils.nativePrototypes.has(proto)) {\n      Object.defineProperty(clone, '__proto__', {\n        value: dehydrate(proto),\n        enumerable: true // ensure that it will show up as a result of stringification\n      });\n    }\n    // include the original's constructor if it has one\n    if (utils.hasNonNativeConstructor(original)) {\n      const constructor = original.constructor;\n      if (constructor instanceof Object && constructor.prototype === original) {\n        clone.constructor = dehydrate(constructor);\n      }\n    }\n    // include all keys in original not yet accounted for by the source\n    utils.each(original, function (k, v) {\n      // make sure not to double include numerical array keys already in the source\n      if (source && utils.isPlainOrTypedArray(original) && !Number.isNaN(Number(k))) return;\n      clone[k] = dehydrate(v);\n    });\n    return clone;\n  }\n\n  // convert something into a rehydratable format\n  function dehydrate (thing) {\n    // simple values (non-special booleans, numbers, and strings) remain themselves\n    if (utils.isSimple(thing)) return thing;\n    if (!idCache.has(thing)) {\n      // incorporate the object into the cache\n      const dehydrated = assoc(thing);\n      // set its type (helps streamline deserialization)\n      dehydrated.type = utils.isopodTypeOf(thing);\n      // set its \"source\" value (helps streamline deserialization)\n      dehydrated.source = sourceValueFrom(thing, dehydrated.type);\n      // set any additional keys not included in the source\n      dehydrated.keys = cloneKeys(thing, dehydrated.source);\n    }\n    // objects are replaced with the id representing their location in the root serialized array (helps streamline deserialization)\n    return [idCache.get(thing)]\n  }\n\n  // kick off the recursive process of dehydrating everything in the original\n  dehydrate(root);\n  \n  return serialized;\n\n};\n\nmodule.exports = serialize;\n\n\n/** WEBPACK FOOTER **\n ** ./src/serialize.js\n **/"],"sourceRoot":""}